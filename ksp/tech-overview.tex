\section{Technical Overview}

Given a $t$-out-of-$n$ sharing $\sk_1, \dots, \sk_n$ of the secret key of a high-value signing keypair $(\vk, \sk)$, we wish to store the shares among a set of hot-cold custodian pairs according to the requirements outlined in \Cref{sec:reqs}. A natural starting point for threshold signatures with the desired hot-cold access structure is to give each hot-cold pair a $2$-out-of-$2$ (additive) sharing of one of the threshold shares.
Even with this simple construction, our system model adds a hurdle to signing because cold parties can communicate only via their respective hot parties. This means that some care has to be taken in the signing procedure to ensure that \emph{both} parties must participate for every signature. In particular, any communication from the cold party to the hot should be ``bound'' to the message $m$ being signed (and some nonce). Otherwise, the hot storage could replay the communication from the cold party and produce a signature on some other message $m' \neq m$ without the cold storage's cooperation, violating our threat model.

For BLS (threshold) signatures, this is not a problem, since signing is already non-interactive and the scheme's homomorphism means we can extend this to the hot-cold case as well.
% Our scheme takes advantage of the natural homomorphism of BLS signatures to use the additive sharing idea. 
As described above, assume that the cold and hot parties hold shares $\sk_i^\cold := r$ and $\sk_i^\hot := \sk_i+r$, respectively, of the threshold signing key share. Then the cold party can send a partial signature $\sigma_i^\cold := \blshash(m)^{\sk_i^\cold}$ to the hot party which is ``bound'' to the message $m$, and the hot party computes its own partial signature $\sigma_i^\hot := \blshash(m)^{\sk_i^\hot}$. The threshold BLS signature $\sigma_i$ can be computed by the hot party as $\sigma_i^\hot/\sigma_i^\cold = \blshash(m)^{\sk_i}$. This scheme also enables proactive refresh of the hot shares basically ``for free'' due to the malleability of the additive sharing: the wallet owner can simply send every hot party a $t$-out-of-$n$ sharing of zero, which the latter adds to its current share. 

Unfortunately, there are two main problems with this construction. First, it is unclear how to securely generate each hot-cold pair's additive sharing without involving a trusted third party or a costly distributed protocol. Assuming the key shares were previously generated via a DKG, the most straightforward option is for a trusted dealer to sample $\sk_i^\cold$ on behalf of each cold party and send it to them over a secure channel\footnote{We assume cold parties register a public key with the dealer or some third-party service.} (via the corresponding $P_i^\hot$). However, to compute the hot shares $\sk_i^\hot$, this dealer must learn the current (potentially refreshed) values of $\sk_i$, undermining their security. Alternatively, holders of the shares $\sk_i$ could engage in a computationally intensive and highly interactive protocol to generate the backup shares. A third option is to generate $\sk_i^\hot, \sk_i^\cold$ as part of the initial DKG, but this would preclude \textit{ad hoc} backups of existing key shares. It would also require all custodians for the backup to be known from the start, ruling out dynamic joins. %In any case, this is not an option for our use case, since we wish to enable hot-cold backups of \emph{existing} secrets.
None of these approaches are desirable: ideally, generating a backup should require little or no interaction between custodians and avoid undermining the security of the high-value secret to be backed up.

The second problem with our strawman construction is enabling independent proofs of remembrance for hot and cold parties. In a simple $t$-out-of-$n$ threshold signature, the secret key shares $\sk_i$ are Shamir shares~\cite{CACM:Shamir79} of the secret key $\sk$. Proving remembrance of these shares is relatively simple because they lie on a degree-$(t-1)$ polynomial: a natural approach for proving knowledge and well-formedness is for the dealer to publish a KZG commitment~\cite{AC:KatZavGol10} to the polynomial and distribute opening proofs for each value $\sk_i$. To truly ensure remembrance of $\sk_i$ at any point in time, a party is required to provide a non-replayable proof; simply forwarding the proof given to it by the dealer should not suffice, since the party may have deleted the key share in the meantime. In fact, a party cannot respond directly with the KZG opening proof regardless, since the opening value---in this case $\sk_i$---is required to verify the proof. To solve this issue, previous work~\cite{CCS:ZBKMNS22} showed how to provide blinded KZG evaluation proofs, also ensuring \emph{knowledge} of the evaluation in the process.

In our strawman construction, however, hot parties have shares $\sk_i^\hot := \sk_i+r_i$, which are no longer guaranteed to lie on a degree-$(t-1)$ polynomial. (The cold proofs are not a problem, since one can use a simple proof-of-knowledge of discrete logarithm to prove remembrance of a cold share $r_i$.) Forcing the $\sk_i^\hot$ to lie on a degree-$(t-1)$ polynomial by computing the cold values $r_i$ as $t$-of-$n$ shares is not an option, as it would require coordination among the normally offline cold parties and run into some of the same problems as hot-cold share generation above. This leaves hot parties with the task of proving knowledge of a value $\sk_i+r_i$ without knowing $\sk_i$ or $r_i$. Even given a KZG commitment and opening proof for $\sk_i$ along with the value $g^{r_i}$, it is unclear how a hot party could produce a proof of knowledge of the sum $\sk_i+r$ without relying again on a trusted setup with a static set of participants. 
% to a general-purpose zk-SNARK. Although this last option could work, it would be computationally expensive for hot storages, require significant additional engineering effort, and add a complicated protocol which is unnecessary for other aspects of the wallet client.\noemi{not sure how convincing this argument is}

\input{ksp/model-fig}

\paragraph{Our approach}
It turns out that there is a way to realize this additive sharing without running into the issues above. Below, we show how to do this in a way that simultaneously enables both non-interactive generation of the backup shares and individual proofs of remembrance.

At a high level, each cold party will sample an encryption keypair $(\ek_i, \dk_i)$. The hot key shares will be encryptions of the secret key shares $\sk_i$ under a malleable encryption scheme. Malleability is needed so the underlying share can be refreshed even in encrypted form. In particular, we use an additive variant of ElGamal encryption~\cite{C:ElGamal84} where the message space is a field. This is necessary since our plaintext will be a field element (namely $\sk_i$) and will be refreshed via addition to the ciphertext.
 % $\sk_i^\hot := \enc(\ek_i, \sk_i)$ for a malleable encryption scheme.

To make an additive variant of ElGamal over a field $\FF$, consider the straightforward modification of ElGamal to use an additive instead of multiplicative mask by letting $\enc(\ek, m) := (g^\rho, m + \ek^\rho)$. However, we said the plaintext $m$ will be a field element, and $\ek$ is a group element. To enable addition, we will make use of an injective function $\lhlhash: \GG \to \FF$ and redefine $\enc(\ek, m) := (g^\rho, m + \lhlhash(\ek^\rho))$. Encryption is still (additively) malleable, so we can add a shift $s \in \FF$ to the message by adding it to the ciphertext, i.e., compute $\enc(\ek, m + s)$ as $\enc(\ek, m) + s$. In the context of the encrypted key share, this means the share $\sk_i$ being held in encrypted form can still be refreshed via addition: given a zero share $z_i$, refresh by computing $\enc(\ek_i, \sk_i) + z_i = \enc(\ek_i, \sk_i + z_i)$.

Returning to hot-cold shares as additive sharings of $\sk_i$, let the hot party's share be the second element of a ciphertext encrypting $\sk_i$ under the cold party's key $\ek_i$; then the cold party's share is the additive mask $\lhlhash(\ek_i^\rho)$. The pair's secret $\sk_i$ is recovered as $\sk_i^\hot - \sk_i^\cold = (m+\lhlhash(\ek_i^\rho)) - \lhlhash(\ek_i^\rho) = \sk_i$. Unfortunately, this construction still requires the cold party's storage to scale linearly with the number of secrets stored by the hot-cold pair. As stated in \Cref{sec:reqs}, we would like to make the cold storage independent of the number of user secrets.

We make one final change to the encryption scheme to accomplish this. Instead of sampling fresh randomness $\rho$ for each ciphertext, $\rho$ will be based on the secret $\sk$ being stored (the high-value signing key being backed up). In particular, we set the cold party's share (and the ciphertext mask) to $\lhlhash(\ek_i^{\sk})$. Since the input is no longer uniformly random, the function $\lhlhash$ must be designed so its output is nevertheless close to uniformly random on high-entropy inputs (we give an efficient construction using the Leftover Hash Lemma in \Cref{sec:enc-lhl}).\footnote{This actually requires us to expand the encryption key to $2$ elements, which we ignore in the presentation here for simplicity.  Please see the body of the paper for full details.} Furthermore, we instantiate the cold encryption keypairs in the same group and using the same generator as the signing keypair, so that $\ek_i^{\sk} = (g^{\dk_i})^{\sk} = \vk^{\dk_i}$. Now each cold party can store only a single element, namely $\dk_i$, regardless of the number of clients. When it receives a signing request, it re-computes its share of $\sk_i$ on-the-fly as $\lhlhash(\vk^{\dk_i}) = \lhlhash(\ek_i^{\sk})$.

A partial BLS signature $\sigma_i$ can be computed by decrypting the hot key share ``in the exponent'': given $m$ and $\vk$, each hot party computes $\sigma_i^\hot := \blshash(m)^{\sk_i^\hot}$ and the corresponding cold party computes $\sigma_i^\cold := \blshash(m)^{\lhlhash(\vk^{\dk_i})}$. The pair's partial signature $\sigma_i$ is computed as $\sigma_i^\hot/\sigma_i^\cold = \blshash(m)^{\sk_i}$, which is equal to a normal partial BLS signature under the $i$th signing key share.

\paragraph{Solving Problem 1: Generating hot-cold shares}
Now that hot shares are public-key encryptions of the secret shares, they can be computed without interacting with the cold parties. Given shares $\sk_1, \dots, \sk_n$ of the high-value key, we can compute each hot share $\sk_i^\hot := \sk_i + \lhlhash(\ek_i^{\sk})$ by using the corresponding cold party's published encryption key.

% At the core of our construction is an ElGamal-like encryption scheme which can be seen as instantiating a $2$-out-of-$2$ secret-sharing where one share can be computed obliviously and independently. We chose to use BLS signatures because their homomorphic nature allows our cold and hot storage to produce partial signatures which are already ``bound'' to the message $m$ to be signed before they are combined into the final threshold signature, preventing the hot storage from replaying the cold storage's message for multiple signatures. Futhermore, the non-interactive nature of BLS allows us to achieve a protocol with a single message from the cold to the hot storage.

\paragraph{Solving Problem 2: Proofs of remembrance}
The independence between hot and cold parties also enables individual proofs of remembrance.
Cold parties can use a standard proof of knowledge of discrete logarithm (for $\dk_i$ corresponding to $\ek_i$), which suffices to prove the party can recover the cold share $\lhlhash(\vk^{\dk_i})$ for any verification key $\vk$. As for hot parties, their shares still do not lie on a degree-$(t-1)$ polynomial, but they do lie on a degree-$(n-1)$ polynomial which the parties can interpolate at backup time. We therefore adapt the KZG-based proof idea to this degree-$(n-1)$ polynomial, with hot parties providing blinded evaluation proofs as their proofs of remembrance. The homomorphism of KZG commitments allows proactive refreshes, and we use a folklore approach to ensure the refreshes are of degree $(t-1) < (n-1)$.