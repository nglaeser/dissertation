\section{Technical overview}

We will use the superscripts $\hot$ and $\cold$, respectively, to denote the hot and cold components of some value, and a subscript $i$ to denote the value corresponds to the $i$th party. For example, the $i$th party's cold signature is written as $\sigma_i^\cold$. We use the words ``user'' and ``client'' interchangeably to refer to the wallet owner.

A starting point for constructing a threshold signature with our desired access structure would be to first compute a $t$-out-of-$n$ sharing $\sk_1, \dots, \sk_n$ of the signing key $\sk$, then give each hot-cold pair a $2$-out-of-$2$ (additive) sharing $\sk_i^\hot, \sk_i^\cold$ of one of the threshold shares. 
% \noemi{we do kind of do this, i.e., share $\sk_i$ as $r, \sk_i + r$ and have hot/cold signature shares $\sigma_i^\cold := \blshash(m)^r, \sigma_i^\hot := \blshash(m)^{\sk_i+r}$ which are combined as $\sigma_i^\hot/\sigma_i^\cold$. So we need to justify why instead of randomly sampling $r$ we use $r := \lhlhash(\ek_i^{\sk}) = \lhlhash(y^{\dk_i})$.}
% This approach runs into problems when we consider the signing procedure: for a generic threshold signing procedure, producing a threshold signature under the share $\sk_i$ is unlikely to require only one round of communication between the cold and hot party. 
The signing protocol has to be designed carefully, since we need to ensure that any communication from the cold party to the hot is ``bound'' to the message $m$ being signed. Otherwise, the hot storage could replay the communication and produce a signature on some other message $m' \neq m$ without the cold storage's cooperation, violating our threat model.
% How can the hot and cold storages reconstruct their signing key share to produce a partial signature when they have only a one-way channel between them? If the threshold signing protocol is highly interactive, how does the cold storage interact with the rest of the signing parties when it cannot receive messages and can only communicate with its corresponding hot storage? Does such a protocol expose the cold party's key material to the other, thereby rendering the extra level of sharing superfluous and collapsing the threat model back down to the standard $t$-out-of-$n$ corruptions?

Our scheme takes advantage of the natural homomorphism of BLS signatures to use the additive sharing idea. At a high level, the cold and hot parties will receive shares $r$ and $\sk_i+r$, respectively, of the threshold signing key share. Then the cold storage can send the hot storage a partial signature $\sigma_i^\cold := \blshash(m)^r$ which is ``bound'' to the message $m$, and the hot storage computes its own partial signature $\sigma_i^\hot := \blshash(m)^{\sk_i+r}$. The threshold BLS signature $\sigma_i$ can be computed by the hot storage as $\sigma_i^\hot/\sigma_i^\cold = \blshash(m)^{\sk_i}$. This scheme also enables proactive refresh of the hot shares basically ``for free'' due to the malleability of the additive sharing: the wallet owner can simply send every hot storage a $t$-out-of-$n$ sharing of zero, which the hot storage adds to its current share.

% \paragraph{Non-interactive cold key generation} 
Our idea for realizing this additive sharing is to allow each cold party to sample an encryption key-pair $(\ek_i, \dk_i)$ and let the cold share $r$ be a deterministic function of $\ek_i$ and the client signing key $\sk$. In particular, we want to set $r := \lhlhash(\ek_i^{\sk})$ for a carefully-designed efficient hash function $\lhlhash$.
% We use an ElGamal-like encryption scheme where the encryption of a message $m$ with randomness $\rho$ is defined as $\lhlhash(\ek_i^\rho) + m$. 
Put another way, this means the hot key share will be an encryption of $\sk_i$ under the cold party's public key $\ek_i$.
This allows the hot key material to be computed by a key generation protocol which outputs the verification key $\vk = g^{\sk}$ and each hot party's key share $\sk_i + \lhlhash(\ek_i^{\sk})$ without interacting with the cold parties. The crucial piece is that each cold encryption key-pair will be instantiated in the same group and using the same generator as the signing key-pair, so $\ek_i^{\sk} = (g^{\dk_i})^{\sk} = \vk^{\dk_i}$. Thus, given the verification key, each cold storage can now independently recover its signing key share $r$ as $\lhlhash(\vk^{\dk_i})$. This means that a partial signature is effectively computed by decrypting the hot key share ``in the exponent'' of the partial BLS signature.

% At the core of our construction is an ElGamal-like encryption scheme which can be seen as instantiating a $2$-out-of-$2$ secret sharing where one share can be computed obliviously and independently. We chose to use BLS signatures because their homomorphic nature allows our cold and hot storage to produce partial signatures which are already ``bound'' to the message $m$ to be signed before they are combined into the final threshold signature, preventing the hot storage from replaying the cold storage's message for multiple signatures. Futhermore, the non-interactive nature of BLS allows us to achieve a protocol with a single message from the cold to the hot storage.

To prove remembrance, each type of party uses its own proof system. For cold parties, a standard proof of knowledge of discrete logarithm (for $\dk_i$ corresponding to $\ek_i$) suffices. For the hot parties, the relation is more complicated since the shares are no longer simply points on a degree-$t$ polynomial. 
% and the proof system must accommodate share refreshes. 
We give a proof system based on KZG commitments which leverages their multiplicative homomorphism to enable compatibility with hot share refreshes. 

%Before describing our construction in more detail, we mention some related work.