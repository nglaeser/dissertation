\section[\sysname: Hot-Cold Threshold BLS with Proofs of Remembrance and Proactive Refresh]{\sysname: Hot-Cold Threshold BLS with\texorpdfstring{\\}{} Proofs of Remembrance and Proactive Refresh}\label{sec:bls-construction}

% \input{src/construction-ucsyntax}
In this section, we show how to use the encryption scheme from \Cref{sec:keyshares} and the proofs of remembrance from \Cref{sec:hotproofs} to construct an \hcwl using BLS signatures (recalled in \Cref{sec:bls}). 

Let $\GG_1, \GG_2$ be elliptic curve groups of order $p$ generated by $g_1$ and $g_2$, respectively, and $e: \GG_1 \times \GG_2 \rightarrow \GG_T$ be an efficiently computable asymmetric (type-3) pairing between them. 
Since $\vk \in \GG_2$, we will also instantiate the additive ElGamal encryption over $\GG_2$. 
Let $\blshash: \{0, 1\}^* \rightarrow \GG_1$ and $\lhlhash: \GG_2^2 \rightarrow \ZZ_p$ be hash functions as defined in \Cref{sec:bls} and \Cref{sec:keyshares}, respectively.

\subsection{Subprotocols}

\input{ksp/functionalities/SS}
\input{ksp/functionalities/PK}

We assume the existence of the following ideal functionalities, which we will use as building blocks for our protocol:
\begin{description}
\item[(Encrypted) secret share generation $\Fs$:]
    Presented in \Cref{fig:Fs}, this functionality is executed between a client $C$ 
    % a set of volunteer helpers, 
    and a set of custodians (institutional entities). %, where each institutional entity is modeled by a hot server and a cold server.
    The functionality allows the client to choose which institutional entities it wants to use. 
    We require that the client provide the public keys of the institutional servers that it wants to engage. 
    % \todo{define role of volunteers} 
    A direct way to implement the $\Fs$ functionality would be for (trusted) $C$ to execute the steps of $\Fs$ on input $\mathsf{SSSetup}$ locally and send $\hx_i$ to $P_i^\hot$ for each $i$ via a point-to-point channel.
    While this suffices for a number of applications, we model it as an abstract ideal functionality as we will be interested in settings where security is desired even if $C$ (i) does not have access to a source of true randomness, or (ii)  is (or, may in future be) corrupted. 
    In \Cref{sec:fs_protocol}, we show that one can use an additional proof system $\Pi_{\sf Ref}$ and a public bulletin-board with limited programmability to avoid trusting $C$ beyond the key generation phase. We leave a fully decentralized key generation protocol to future work.
    % In \Cref{sec:dkg} we give a protocol which implements $\Fs$ in a distributed manner.
    % Looking ahead, in this formalism, we will depend on which/how many of the volunteers are honest. We remark that the institutional entities may also play the role of volunteers in this system.
    
\item[Public key infrastructure $\Fpk$:] 
Finally, we assume a functionality $\Fpk$ (\Cref{fig:Fpk}) which allows a party (institutional cold servers in our case) to obtain a secret (decryption) key $\dk$ sampled from $\ZZ_p$ while its public (encryption) key $\ek := g_2^{\dk}$ is made public, and can be retrieved reliably by any client. Again this functionality can be implemented by a party executing it locally. We abstract it out to separate the implementation details of this functionality from our modeling.

\end{description}

% \paragraph{A note about hot and cold parties.} In our system, an institutional entity $I_i = (P_i^\hot, P_i^\cold)$ is modeled as two parties (a hot and cold server). Except for our main hot-cold functionality $\FSign$, our ideal functionalities (in \Cref{fig:Fs,fig:Fpk}) do not specify whether they can be called by a hot or cold party, and indeed they can be called by either. We use the letter $P$ (without a $\hot$ or $\cold$ superscript) to show that these functionalities can be run for either party.

% \paragraph{Setup.} We consider the following ideal functionality $\Fs$ (see Figure~\ref{fig:Fs}) 

\paragraph{Construction}

\newcommand{\corrc}[1]{\textcolor{blue}{#1}}
\input{ksp/protocols/bls-hcwl1}
\input{ksp/protocols/bls-hcwl2}

\sysname, our BLS-based \hcwl protocol, is given in \Cref{fig:hc_bls1,fig:hc_bls2}. Each cold storage is set up separately and independently of any client (user) via the $\mathsf{ColdRegister}$ protocol. When a client registers, it specifies a set of $n$ institutions $\mathcal{I}$ and a threshold $t \leq n$ of them required for signing. The $\mathsf{ClientRegister}$ protocol is an interactive protocol between $C$ and the $n$ hot parties specified by $\mathcal{I}$ which outputs a verification key $\vk$ to the client and an encrypted secret key share $\hx_i$ to each hot party. Each hot party also receives a proof $\pi_i$ which will allow it to prove that $\hx_i$ was the output of $\mathsf{ClientRegister}$.

To sign a message $m$ on behalf of $C$, each institution (consisting of a hot and cold party) separately produces a partial signature on $m$. Upon receiving a signature request,\footnotemark\ each component can honor the request by producing a partial signature $\sigma_i^\hot$ or $\sigma_i^\cold$, respectively, which the hot party combines into $\sigma_i$.
\footnotetext{In most implementations, requests would be passed to each cold party via the corresponding hot party. To prevent a malicious hot party from sending spurious requests to its cold party, one could instantiate an authenticated channel  over the hot parties between the client and each cold party.}
% \noemi{Do a pass on this description. We write that $C$ sends requests to the cold parties; comment that, in practice, there is no direct channel to the cold parties and one could instantiate this via authenticated channel between $C$ and each cold party over the hot parties.}

Proving remembrance of each party's key material is done via $\mathsf{CProof}$ and $\mathsf{HProof}$, respectively. We write that $P_i^\cold$ sends its proof directly to $C$, which in practice can be achieved by passing the message via $P_i^\hot$ assuming eventual delivery.
Finally, the hot key shares can be proactively refreshed via an interactive protocol $\shref$ between $C$ and the hot parties, which is similar to $\mathsf{ClientRegister}$ and outputs some update information $\delta_i$ and a proof $\zeta_i$ of its correctness to each hot party.

\paragraph{Correctness}
Let $\mathcal{I}$ be the set of $n$ institutions with which $C$ registers using threshold $t$. For $i \in [n]$, let $\ek_i$ be the output of $\mathsf{ColdRegister}$ for $P_i^\cold$, $\vk$ be the output of $\mathsf{ClientRegister}$, $\com_\timeT$ be the polynomial commitment after $\timeT$ executions of $\shref$, and $\pi_i^\hot$ (resp. $\pi_i^\cold$) be the output of $\hProof$ for $P_i^\hot$ and $C$ (resp. $\cProof$ for $P_i^\cold$ and $C$).
For correctness, we require that for all $\timeT$, if there exists some set $S = \{i: i \in [n]\}$ with $\sizeof{S} \geq t$ such that $\Pi_{\sf EKS}.\vrfy(\crs, \com_\timeT,\allowbreak \pi_i^\hot) = 1$ and $\Pi_{\sf DL}.\vrfy((\ek_i, g_2), \pi_i^\cold) = 1$ for all $i \in S$,
then $\mathsf{BLS}.\vrfy(\vk,\allowbreak m, \mathsf{BLS}.\recon(\{\sigma_i\}_{i \in S})) = 1$ with all but negligible probability, where $\sigma_i$ is the output of $\mathsf{TSign}$ for $P_i^\hot, C, m$.

Recall that $\mathsf{TSign}$ outputs computes $\sigma_i$ as $\sigma_i^\hot/\sigma_i^\cold$, which by construction equals $\blshash(m)^{\sk_i + \lhlhash(\ek_i^{\sk})} \cdot \blshash(m)^{-\lhlhash(\vk^{\dk_i})} = \blshash(m)^{\sk_i} = \mathsf{BLS}.\mathsf{TSign}(\sk_i, m)$. Thus correctness follows by construction, the soundness of $\Pi_{\sf DL}$ and $\Pi_{\sf EKS}$, and the correctness of threshold BLS.

\paragraph{Efficiency and compactness of cold storage}
We wish to point out that our construction optimizes storage-, computation-, and communication-efficiency for the cold parties. Each $P_i^\cold$ only stores a single decryption key $\dk_i \in \GG_2^2$, regardless of the number of clients registered with its institution. To produce a cold partial signature, it computes two $\GG_2$ exponentiations, one addition in $\ZZ_p$, and a single evaluation of $\lhlhash$, which is highly efficient since it is a simple subset sum (see \Cref{sec:keyshares}). Computing a proof of remembrance requires 2 $\GG_2$ exponentiations, 1 hash function evaluation (for Fiat-Shamir), and 2 additions and multiplications each in $\ZZ_p$. Finally, in terms of communication, a cold party only needs to send a single $\GG_1$ element per signing operation. A cold proof of remembrance consists of 2 $\GG_2$ and 2 $\ZZ_p$ elements.