In the cryptocurrency ecosystem, anyone who controls the signing key for some account can take actions on the user's behalf. This makes signing keys very valuable cryptographic material, since they can allow an attacker to transfer potentially large sums of money out of a user's account with no recourse. A plethora of solutions has emerged to safeguard these keys in the form of cryptocurrency wallets.

Wallets can be classified into two types: custodial and non-custodial solutions. In a custodial wallet, a client trusts some third party (the custodian) to store the signing key on their behalf and use it to authorize transactions at their request. This clearly requires a strong trust assumption but relieves the client of the need to securely store such a high-value secret. At the other end of the spectrum, non-custodial wallets require clients to store their own signing keys, e.g., on their machine or in a hardware wallet~\cite{FC:AGKK19}. This can be a usability issue, since by definition there cannot be a recovery or reset mechanism in case the client loses the key file or hardware wallet, or if the key material is compromised. An increasingly common compromise between these two extremes are threshold wallets~\cite{SP:KMOS21,EPRINT:DEFLR23,EPRINT:BloMakPel22,EPRINT:Eyal21}. These are essentially custodial wallets with multiple custodians, where each one is given only a share of the signing key. This maintains the usability advantages of custodial wallets while reducing the trust placed in any single custodian.
Unfortunately, the normally highly-interactive threshold signing procedures require custodians to be online during the signing phase, making them vulnerable to attacks aiming to learn their shares~\cite{ecdsa-threshold-attack,NIST-MPC-Attack}.

% \anote{If I understand correctly, we want to motivate two key points: the use of hot/cold storage as opposed to only hot storage. The need for proofs of remembrance. Maybe we should give paragraph headers to each of these ideas.} 
\paragraph{Cold wallets}
A common mitigation is to keep only limited funds in the online wallet, with most of a user's assets kept in a highly secure air-gapped wallet. This can be realized via, e.g., a deterministic wallet~\cite{deterministic-wallets,CCS:DasFauLos19,CCS:ADEFKRS20,EPRINT:Hu23,ESORICS:ErwRia22}, which enables unlinkable transfers to an offline wallet by specifying how to deterministically derive session keys from a master public-private key pair. Thus, the online wallet can compute and publish the current session public key, allowing anyone to transfer money to the cold wallet (which can derive the corresponding session private key). 

This idea is standardized by the BIP32 proposal~\cite{bip32}, which also defines how these session keys can be derived in a hierarchical manner to create ``child'' wallets who can control their own funds. 
Because the master secret key (and any session/child secret keys) must still be stored in a trusted place, this makes the offline wallet a highly valuable target when it inevitably comes online to transfer funds to the online wallet.
Although a recent work~\cite{EPRINT:DEFLR23} shows how to enable threshold child wallets, the issue of a single point of failure still persists at the root wallet.

\paragraph{Ensuring availability}
Another problem arises when the responsibility to store key material is delegated solely to external custodians who have no explicit incentive to make sure the key stays available: custodians may be lazy and stop storing the key material as a way to save space and money, relying on the assumption that the other custodians will act honestly and store their corresponding shares. Even in the case in which all custodians have honest intentions, a client with a large sum of money in their threshold wallet may still wish to intermittently check that a custodian has access to its key material. To our knowledge, no wallet explicitly implements such a feature, although a similar effect can be achieved by requesting approval of an empty transaction, since this makes it clear that at least $t$ of the parties still hold their shares (although not necessarily which ones). A more targeted audit could be implemented via generic zero-knowledge proofs requiring a party to prove knowledge of the $i$th key share using some time-based challenge, but the practical efficiency of such a proof is unclear. 
% especially in the case of more complicated schemes such as hierarchical or deterministic wallets.\anote{This last line is a bit vague and also not specially relevant to us since we are not building hierarchical solutions. Also, the proofs need to incorporate a ``current'' challenge, no? Since otherwise, one can pre-compute a bunch of proofs and release them later one at a time.}