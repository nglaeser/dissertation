\subsection{Formal Definitions}\label{sec:naysayer_def}

Next, we introduce a formal definition and syntax for naysayer proofs. A naysayer proof system $\Pi_{\nay}$ can be seen as a ``wrapper'' around an underlying proof system $\Pi$. For example, $\Pi_{\sf nay}$ defines a proving algorithm $\Pi_{\nay}.\prove$ which uses the original prover $\Pi.\prove$ as a subroutine.

\begin{definition}[Naysayer proof]\label{def:naysayer_proof}
Given a non-interactive proof system $\Pi = (\setup, \prove, \vrfy)$ for a NP language $\Lang$, the naysayer proof system corresponding to $\Pi$ is a tuple of PPT algorithms $\Pi_{\nay} = (\setup, \prove,\allowbreak \naysay, \vrfynay)$ defined as follows:
    \begin{description}
        \item[$\setup(\secparam, 1^{\naysecparam}) \randout (\crs,\crs_{\nay})$:] Given (potentially different) security parameters $\secparam$ and $1^{\naysecparam}$, output two common reference strings $\crs$ and $\crs_{\nay}$. This algorithm may use private randomness.
        \item[$\prove(\crs, x, \witness) \to \pi'$:] Given a statement $x$ and witness $\witness$ such that $(x,\allowbreak \witness) \in \Rel$, 
        % compute $\pi \gets \Pi.\prove(\crs, x,w)$ and a commitment $\com$ to the evaluation trace of $\Pi.\vrfy(\crs, x, \pi)$. 
        output $\pi' = (\pi, \aux)$, where $\pi \in \Pi.\prove(\crs, x, \witness)$.
        \item[$\naysay(\crs_\nay, (x,\pi'), \witness_{\nay}) \rightarrow \pi_{\nay}$:] Given a statement $x$ and values $\pi' = (\com,\allowbreak \pi)$ where $\pi$ is a (potentially invalid) proof that $x \in \Lang$ using the proof system $\Pi$, output a naysayer proof $\pi_\nay$ disputing $\pi$. This algorithm may also make use of some (private) auxiliary information $\witness_\nay$.
        \item[$\vrfynay(\crs_\nay, (x,\pi'), \pi_\nay) \rightarrow \{0, \perp\}$:] Given a statement-proof pair $(x,\allowbreak \pi'=(\pi,\aux))$ and a naysayer proof $\pi_\nay$ disputing $\pi'$, output a bit indicating whether evidence against $\pi$ is sufficient to reject (0) or inconclusive ($\perp$).
    \end{description}
\end{definition}

%Naysayer proofs are most interesting if $\vrfynay$ takes less time than directly verifying the proof $\pi$, i.e., running the $\vrfy$ algorithm. 
A trivial naysayer proof system always exists in which $\pi_\nay = \perp$, $\pi' = (\pi, \perp)$, and $\vrfynay$ simply runs the original verification procedure, outputting $0$ if $\Pi.\vrfy(\crs, x, \pi) = 0$ and $\perp$ otherwise.
We say a proof system $\Pi$ is \emph{efficiently naysayable} if there exists a corresponding naysayer proof system $\Pi_{\nay}$ such that $\vrfynay$ is asymptotically faster than $\vrfy$. If $\vrfynay$ is only concretely faster than $\vrfy$, we say $\Pi_{\nay}$ is a \emph{weakly efficient} naysayer proof. Note that some proof systems already have constant proof size and verification time~\cite{EC:Groth16,C:Schnorr89} and therefore can, at best, admit only weakly efficient naysayer proofs. 
Moreover, if $\witness_\nay = \perp$, we say $\Pi_\nay$ is a \emph{public} naysayer proof (see \Cref{sec:naysayer_apps} for an example of a non-publicly naysayble proof). 

\begin{definition}[Naysayer completeness]
    Given a proof system $\Pi$, a naysayer proof system $\Pi_{\nay} = (\setup, \prove, \naysay, \vrfynay)$ is \emph{complete} if, for all honestly generated $\crs, \crs_{\nay}$, all statements $x$, all invalid proofs $\pi$, and all corresponding auxiliary information $\aux_{\nay}$, $\naysay$ outputs a valid naysayer proof $\pi_{\nay}$. That is:
\begin{equation*}
    \Pr\left[
        \vrfynay(\crs_{\nay}, (x,\pi'), \pi_{\nay})=0 
        \middle| 
        \begin{array}{c}
            (\crs, \crs_{\nay}) \gets \setup(\secparam, 1^{\naysecparam})~\land\\
            \Pi.\vrfy(\crs, x,\pi)=0~\land\\
            \pi_{\nay} \gets \naysay(\crs_{\nay}, (x, \pi'), \witness_{\nay})
        \end{array}
    \right] = 1.
\end{equation*}
\end{definition}

\begin{definition}[Naysayer soundness] Given a proof system $\Pi$, a naysayer proof system $\Pi_{\nay}$ is \emph{sound} if, for all PPT adversaries $\adv$ and for all honestly generated $\crs, \crs_\nay$, all statements $x$ and auxiliary information $\aux_{\nay}$, and all correct proofs $\pi$, $\adv$ produces a passing naysayer proof $\pi_{\nay}$ with at most negligible probability:
\begin{equation*}
    \Pr\left[
        \vrfynay(\crs_{\nay}, (x,\pi'), \pi_{\nay})=0 
        \middle| 
        \begin{array}{c}
            (\crs, \crs_{\nay}) \gets \setup(\secparam, 1^{\naysecparam})~\land\\
            \Pi.\vrfy(\crs, x,\pi)=1~\land\\
            \pi_{\nay} \gets \adv(\crs_{\nay}, (x, \pi), \witness_{\nay})
        \end{array}
    \right] \leq\mathsf{negl}(\naysecparam).
\end{equation*}
\end{definition}

We show that every proof system has a logarithmic (in the size of the verification circuit) naysayer proof with constant verification time (i.e., a succinct naysayer proof). %We follow the blueprint of~\cite{FOCS:FeiLapSha90}.

\todo{Edit the below to replace $\COM$ with the general assumption that all parties have query access to the (prover's?) verification trace (which could be instantiated via e.g. binding commitments, or blob storage, etc.)}

\begin{lemma}\label{lemma:naysayingCSAT}
    A satisfying assignment for a circuit $C: \mathcal{X} \to \{0,1\}$ on input $x \in \mathcal{X}$ is efficiently naysayble. That is, if $C(x) \neq 1$, there exists a $O(\log{\sizeof{C}})$-size proof of this fact which can be checked in constant-time.
    % For every NP language $\Lang$ with relation $\Rel_\Lang$, \todo{change to CSAT specifically}
    % assuming a binding commitment scheme with constant-size openings, 
    % there exists a naysayer proof system $\Pi_{\nay}$ with logarithmic-sized proofs $\pi_{\nay}$ and constant-time verifier.
\end{lemma}
\begin{proof}
    % For any NP language $\Lang$, there exists a non-interactive proof system $\Pi = (\setup, \prove, \vrfy)$ for $\Rel_\Lang$ where $\vrfy(\crs, \cdot, \cdot)$ can be represented as a boolean circuit $C$ of size $\mathsf{poly}(\lvert x \rvert)$~\cite{C:LapSha90}. Recall that for all $(x,w) \in \Rel_\Lang$ and $\crs \gets \Pi.\setup(\secparam)$, by correctness, we have that if $\pi' \gets \Pi.\prove(\crs, x, w)$ then $C(x,\pi') = 1$. Therefore, if there is some gate of $C$ for which the wire assignment is inconsistent, then the proof $\pi'$ is incorrect. To naysay, i.e., to show the incorrectness of $\pi'$, the naysayer simply provides the index of the inconsistent gate.
    % Recall that the verifier has access to the wire assignments of $C(x,\pi')$ as part of $\pi$ (see \Cref{def:naysayer_proof}). 
    We assume that the claimed satisfying assignment is public and fixed and (without loss of generality) that $C$ has fan-in 2. 
    
    If $C(x) \neq 1$, then there must be some gate of $C$ for which the assignment is inconsistent. Let $i$ be the index of this gate (note $\sizeof{i} \in O(\log{\sizeof{C}})$). To confirm that $C(x) \neq 1$, a party can re-evaluate the indicated gate $G_i$ on its inputs $a,b$ and compare the result to the claimed gate output $c$ in the satisfying assignment. That is, if $G_i(a,b) \neq c$, the verifier rejects the satisfying assignment $x$.
    % The verifier then checks whether the wire assignments of $C(x,\pi')$ are consistent with a correct evaluation of the gate, which is a constant-time operation assuming constant-time indexing into the wire assignments. 
    % Furthermore, the naysayer proof consists only of the gate index, which is logarithmic in the circuit size, i.e., succinct.
\end{proof}

\begin{theorem}
    Every efficient proof system $\Pi$ (i.e., with a polynomial-time verification algorithm) has a succinct naysayer proof.
\end{theorem}
\begin{proof}
Given any proof system $\Pi$, the evaluation of $\Pi.\vrfy(\crs,\cdot,\cdot)$ can be represented as a circuit $C$ with fan-in 2. (The circuit description is assumed to be public.) Let $\COM$ be a deterministic, binding commitment scheme with succinct openings and $\com \gets \COM.\Commit(\Pi.\vrfy(\crs,x,\pi))$ be a commitment to the verification trace of a statement-proof pair $(x,\pi)$. We can construct a naysayer proof system as follows:

\begin{description}
    \item[$\setup(\secparam, \naysecparam)$:] Output $\crs \gets \Pi.\setup(\secparam)$ and $\crs_\nay \gets \COM.\setup(\naysecparam)$.
    \item[$\prove(\crs, x, w) \to \pi'$:] Let $\pi \gets \Pi.\prove(\crs, x, w)$ and $\com \gets \COM.\Commit(\Pi.\vrfy(\crs, x, \pi))$. Output $\pi' = (\com, \pi)$.
    \item[$\naysay(\crs_\nay, (x, \pi'), \aux_\nay)$:] Evaluate $\Pi.\vrfy(\crs, x, \pi)$. If the result is not 1, find the index $i$ of an inconsistent gate $G_i(a,b) \neq c$ in the evaluation of $\Pi.\vrfy(\crs, x, \pi)$ committed by $\com$. \noemi{This adds a decent amount of inefficiency...} Let $\pi_a,\pi_b,\pi_c$, respectively, be the opening proofs of $\com$ at the positions of $a,b,c$ (these can be publicly computed since $\COM$ is deterministic \todo{check this}). Output $\pi_{\nay} = (i, (a, \pi_a), (b, \pi_b), (c, \pi_c))$.
    \item[$\vrfynay(\crs_\nay, (x, \pi'), \pi_\nay)$:] Parse $\pi_\nay = (i, (a, \pi_a), (b, \pi_b), (c, \pi_c))$ and check the opening proofs $\pi_a, \pi_b, \pi_c$. Then check $G_i(a, b) \neq c$. If any of the checks fail, output $\perp$; else output 0, indicating rejection of the original proof $\pi'$.
\end{description}

\noemi{Should this be written more generally assuming query access to the prover's verification trace? Then that could be implemented via prover binding+deterministic commitments (?), blob data (aka trusted KZG), Merkle trees, etc.}

Completeness (if a proof is incorrect, we can naysay it) follows by \todo{... soundness of $\Pi$?}
Soundness (if a proof is correct, we cannot give a convincing naysayer proof) is due to \todo{... binding of $\COM$? and something else}
Succinctness of $\pi_\nay$ follows from the succinctness of $\COM$ and by the fact that $i \in O(\sizeof(\Pi.\vrfy(\crs, \cdot, \cdot))) \in O(\log{\sizeof{w}})$ (by the succinctness \todo{define and check} of $\Pi$).
\end{proof}