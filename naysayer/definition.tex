\subsection{Formal Definitions}\label{sec:naysayer_def}

Next, we introduce a formal definition and syntax for naysayer proofs. A naysayer proof system $\Pi_{\nay}$ can be seen as a ``wrapper'' around an underlying proof system $\Pi$. For example, $\Pi_{\sf nay}$ defines a proving algorithm $\Pi_{\nay}.\prove$ which uses the original prover $\Pi.\prove$ as a subroutine.

\begin{definition}[Naysayer proof]\label{def:naysayer_proof}
Given a non-interactive proof system $\Pi = (\setup, \prove, \vrfy)$ for some NP relation $\Rel_\Lang$ for the language $\Lang$, the corresponding naysayer proof system $\Pi_{\nay}$ is a tuple of PPT algorithms $(\setup, \prove,\allowbreak \naysay, \vrfynay)$ defined as follows:
    \begin{description}
        \item[$\setup(\secparam, 1^{\naysecparam}) \randout (\crs,\crs_{\nay})$:] Given (potentially different) security parameters $\secparam$ and $1^{\naysecparam}$, output two common reference strings $\crs$ and $\crs_{\nay}$. This algorithm may use private randomness.
        \item[$\prove(\crs, x, \witness) \to \pi'$:] Given a statement $x$ and witness $\witness$ such that $(x,\allowbreak \witness) \in \Rel$, compute $\pi \gets \Pi.\prove(\crs, x,w)$ and a commitment $\com$ to the evaluation trace of $\Pi.\vrfy(\crs, x, \pi)$. Output $\pi' = (\com, \pi)$.
        \item[$\naysay(\crs_{\nay}, (x,\pi'), \aux_{\nay}) \rightarrow \pi_{\nay}$:] Given a statement $x$ and values $\pi' = (\com,\allowbreak \pi)$ where $\pi$ is a (potentially invalid) proof that $x \in \Lang$ using the proof system $\Pi$, output a naysayer proof $\pi_{\nay}$ disputing $\pi$. This algorithm may also make use of some (private) auxiliary information $\aux_{\nay}$.
        \item[$\vrfynay(\crs_{\nay}, (x,\pi'), \pi_{\nay}) \rightarrow \{0, \perp\}$:] Given a statement-proof pair $(x,\allowbreak \pi'=(\com,\allowbreak\pi))$ and a naysayer proof $\pi_{\nay}$ disputing $\pi$, output a bit indicating whether evidence against $\pi$ is sufficient to reject (0) or inconclusive ($\perp$).
    \end{description}
\end{definition}

%Naysayer proofs are most interesting if $\vrfynay$ takes less time than directly verifying the proof $\pi$, i.e., running the $\vrfy$ algorithm. 
A trivial naysayer proof system always exists in which $\pi_\nay = \varnothing$, $\pi' = (\perp, \pi)$, and $\vrfynay$ simply runs the original verification procedure, outputting $0$ if $\Pi.\vrfy(\crs, x, \pi) = 0$ and $\perp$ otherwise.
We say a proof system $\Pi$ is \emph{efficiently naysayable} if there exists a corresponding naysayer proof system $\Pi_{\nay}$ such that $\vrfynay$ is asymptotically faster than $\vrfy$. If $\vrfynay$ is only concretely faster than $\vrfy$, we say $\Pi_{\nay}$ is a \emph{weakly efficient} naysayer proof. Note that some proof systems already have constant proof size and verification time~\cite{EC:Groth16,C:Schnorr89} and therefore can, at best, admit only weakly efficient naysayer proofs. 
Moreover, if $\aux_\nay = \varnothing$, we say $\Pi_{\nay}$ is a \emph{public} naysayer proof (see \Cref{sec:naysayer_apps} for an example of a non-publicly naysayble proof). 

\begin{definition}[Naysayer correctness]
    Given a proof system $\Pi$, a naysayer proof system $\Pi_{\nay} = (\setup, \prove, \naysay, \vrfynay)$ is \emph{correct} if, for all honestly generated $\crs, \crs_{\nay}$, all statements $x$, all invalid proofs $\pi$, and all corresponding auxiliary information $\aux_{\nay}$, $\naysay$ outputs a valid naysayer proof $\pi_{\nay}$. That is:
\begin{equation*}
    \Pr\left[
        \vrfynay(\crs_{\nay}, (x,\pi'), \pi_{\nay})=0 
        \middle| 
        \begin{array}{c}
            (\crs, \crs_{\nay}) \gets \setup(\secparam, 1^{\naysecparam})~\land\\
            \Pi.\vrfy(\crs, x,\pi)=0~\land\\
            \pi_{\nay} \gets \naysay(\crs_{\nay}, (x, \pi'), \aux_{\nay})
        \end{array}
    \right] = 1.
\end{equation*}
\end{definition}

\begin{definition}[Naysayer soundness] Given a proof system $\Pi$, a naysayer proof system $\Pi_{\nay}$ is \emph{sound} if, for all PPT adversaries $\adv$ and for all honestly generated $\crs, \crs_\nay$, all statements $x$ and auxiliary information $\aux_{\nay}$, and all correct proofs $\pi$, $\adv$ produces a passing naysayer proof $\pi_{\nay}$ with at most negligible probability:
\begin{equation*}
    \Pr\left[
        \vrfynay(\crs_{\nay}, (x,\pi'), \pi_{\nay})=0 
        \middle| 
        \begin{array}{c}
            (\crs, \crs_{\nay}) \gets \setup(\secparam, 1^{\naysecparam})~\land\\
            \Pi.\vrfy(\crs, x,\pi)=1~\land\\
            \pi_{\nay} \gets \adv(\crs_{\nay}, (x, \pi), \aux_{\nay})
        \end{array}
    \right] \leq\mathsf{negl}(\naysecparam).
\end{equation*}
\end{definition}

\todo{Update this framing. Makes more sense to say that every \emph{proof system} (succinct or not) has a \emph{succinct}---i.e., log-size and constant-time verifiable---naysayer proof. (Then the concrete succinctness of the base proof system determines whether the naysayer is efficient/weakly efficient/etc.)} \noemi{This assumes the verification algorithm is already in circuit-form, so not sure this works. CTB Rev1 suggested the phrasing ``for all NP, the trivial proof system has a constant-time and log-size naysayer''.} 

We show that every proof system has a logarithmic-size naysayer proof with constant verification time (i.e., a succinct naysayer proof). %We follow the blueprint of~\cite{FOCS:FeiLapSha90}.

\begin{lemma}\label{thm:naysayingNPCircuit}
    For every NP language $\Lang$ with relation $\Rel_\Lang$, \todo{change to CSAT specifically}
    % assuming a binding commitment scheme with constant-size openings, 
    there exists a naysayer proof system $\Pi_{\nay}$ with logarithmic-sized proofs $\pi_{\nay}$ and constant-time verifier.
\end{lemma}
\begin{proof}
    For any NP language $\Lang$, there exists a non-interactive proof system $\Pi = (\setup, \prove, \vrfy)$ for $\Rel_\Lang$ where $\vrfy(\crs, \cdot, \cdot)$ can be represented as a boolean circuit $C$ of size $\mathsf{poly}(\lvert x \rvert)$~\cite{C:LapSha90}. Recall that for all $(x,w) \in \Rel_\Lang$ and $\crs \gets \Pi.\setup(\secparam)$, by correctness, we have that if $\pi' \gets \Pi.\prove(\crs, x, w)$ then $C(x,\pi') = 1$. Therefore, if there is some gate of $C$ for which the wire assignment is inconsistent, then the proof $\pi'$ is incorrect. To naysay, i.e., to show the incorrectness of $\pi'$, the naysayer simply provides the index of the inconsistent gate.
    Recall that the verifier has access to the wire assignments of $C(x,\pi')$ as part of $\pi$ (see \Cref{def:naysayer_proof}). 
    The verifier then checks whether the wire assignments of $C(x,\pi')$ are consistent with a correct evaluation of the gate, which is a constant-time operation assuming constant-time indexing into the wire assignments. 
    Furthermore, the naysayer proof consists only of the gate index, which is logarithmic in the circuit size, i.e., succinct.

    \todo{The above argues completeness (that if a proof is incorrect, we can naysay it). Need also to argue soundness (that if a proof is correct, we cannot give a convincing naysayer proof).}
\end{proof}

\begin{theorem}
    Every efficient proof system $\Pi$ (i.e., with a polynomial-time verification algorithm) has a succinct naysayer proof.
\end{theorem}
\begin{proof}
Given any proof system $\Pi$, one can represent the $\vrfy(\crs,\cdot,\cdot)$ algorithm as a circuit and apply the above lemma to obtain a succinct naysayer proof.
\end{proof}

\noemi{Notice that the naysayer proof consists of an \emph{integer} index (which may only require a few bits to represent). So, even though it is asymptotically logarithmic, in fact it may actually be smaller than many ``regular'' proofs which consist of some group elements (which are normally at least $\secpar$ bits long). -- Need to check this with some common circuit sizes (e.g., the STARK verification circuit) and group element sizes (e.g., BN254 curve G1 element or other).}