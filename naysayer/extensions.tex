\section{Extensions and Future Work}\label{sec:naysayer_extensions}

In the months since the publication of the original paper~\citeThis{FC:SerGlaBon24}, naysayer proofs have already received attention from various groups of practitioners hoping to deploy them in production. We see many interesting directions for investigation, both for immediate deployments and to improve our understanding of this new paradigm and its implications.

\begin{description}
    \item[\textbf{Rollup design space.}] Naysayer proofs can be viewed as a way (one of several) of combining two established solutions---verifiable computation and fraud proofs---to offer different tradeoffs. There may be other ways to combine these two paradigms to achieve different tradeoffs which can be more suited to certain application scenarios. For example, one can imagine a different fraud/naysayer proof hybrid in which the prover sends only the instance $x$, but a challenger can provide a corrected instance $x'$ and proof for the new statement (i.e., ``nesting'' a zk-rollup inside an optimistic rollup). This can reduce both prover and verifier costs, but makes issuing a challenge less accessible than in either VC or fraud proofs.
    % In another example, a biased coin flip is used in each session to decide whether to use VC or an optimistic approach, reducing prover overhead~\cite{nikolaj-note}.
    
    % \todo{edit:} Type-2 naysayer proofs are even more efficient in the optimistic case, as the prover \emph{only sends the instance $x$} and no proofs at all, claiming without evidence that $(x,w) \in \Rel_\Lang$ (this is the same as in the fraud proof paradigm). On the other hand, if the prover's assertion is incorrect, i.e., $(x,w) \notin \Rel_\Lang$, then a naysayer prover provides the correct statement $x'$ such that $(x',w) \in \Rel_\Lang$ 
    % and a corresponding ``regular'' proof $\pi$ such that $\vrfy(\crs, x', \pi) = 1$. Importantly, $x'$ must correspond to the same witness $w$ (which must be known to the challenger). For example, in the case of rollups, the (public) witness $w$ is the set of transactions in the rollup, and the statement $x = (\mathsf{st}, \mathsf{st}')$ is the updated rollup state after applying the batch $w$. Therefore, an incorrect assertion represents an incorrect application of the update $w$. The correction $x'$ is the result of the proper application of $w$.
    % This can be seen as a naysayer proof system where $\pi' = \varnothing$, $\aux_{\nay} = w$, $\pi_{\nay} = (x', \pi_{x'})$, and $\vrfynay$ runs $\Pi.\vrfy(\crs, x', \pi_{x'})$.
    % We conjecture that in most applications, in the worst case, type-2 naysayer proofs are more costly than type-1 naysayer proofs (both compute and storage).

    \item[\textbf{Naysaying zkVMs.}] An emerging trend in zk-rollups are so-called ``zero{\hyp}knowledge virtual machines'', or zkVMs (again, the ``zk'' part may or may not hold). A zkVM expresses each language as program $P$ in a standard instruction set and, given an instance $(a,b) \suchthat b = P(a)$, proves a conjunction of correct state transitions based on $P$ and the instruction set. Given this repetitive structure of the proven relation, challenging an incorrect instance $(a,b) \suchthat b \neq P(a)$ can be done extremely efficiently. Designing proof systems to efficiently disprove state transitions of popular zkVM instruction sets is an interesting direction for future work.
    % \noemi{This kinda creates an $\aux$ already (not for verification, but for the original computation); basically rephrases the statement as a conjunction of state transitions.}

    \item[\textbf{Other naysayer constructions.}] In all of our application-specific naysayer constructions, the verification of the base proof systems was a conjunction. An interesting question to explore is whether there are other application-specific naysayer proofs which are particularly efficient or useful.
    
    \item[\textbf{Computing $\aux$.}] A drawback of (generic) naysayer proofs is that the prover must additionally run $\Pi.\vrfy$ to create the verification trace $\aux$. It would be very useful to separate or outsource this computation to another party to reduce the added computational burden on provers (who are already spending required to spend significant computational power to compute proofs).

    \item[\textbf{Implementing query access.}] \Cref{sec:naysayer_storage} introduced a straightforward way to implement efficient and secure query access to $\pi'$ via a secure data availability service (e.g., Ethereum blob data). Both on- and off-chain, there may be other, more efficient approaches for realizing this access (or removing it entirely) and/or reducing the underlying trust assumptions.
    % blob data (aka trusted KZG) (see \Cref{sec:naysayer_storage}), prover binding+deterministic commitments (?), Merkle trees
\end{description}