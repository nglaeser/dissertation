\subsection{Storage Considerations}\label{sec:naysayer_storage}

We assumed in our evaluation that the naysayer verifier can read the instance $x$, the original proof $\pi$, and the naysayer proof $\pi_\nay$ entirely. Note that in the pessimistic case, the verifier requires increased storage (for $\pi_{\nay}$) but only needs to compute $\vrfynay$ instead of $\vrfy$. A useful naysayer proof system should compensate for increased storage by considerably reducing verification costs.

In either case, this approach of storing all data on chain may not be sufficient in blockchain contexts where storage is typically very costly. 
Blockchains such as Ethereum differentiate costs between persistent storage (which we can call $S_{\sf per}$) and ``call data'' ($S_{\sf call}$), which is available only for one transaction and is significantly cheaper as a result. Verifiable computation proofs, for example, are usually stored in $S_{\sf call}$ with only the verification result persisted to $S_{\sf per}$.

Some applications now use a third, even cheaper, tier of data storage, namely off-chain \emph{data availability services} ($S_{\sf DA}$), which promise to make data available off-chain but which on-chain contracts have no ability to read. Verifiable storage, an analog of verifiable computation, enables a verifier to store only a short commitment to a large vector~\cite{PKC:CatFio13,C:Merkle87} or polynomial~\cite{AC:KatZavGol10}, with an untrusted storage provider ($S_{\sf DA}$) storing the full values. Individual data items (elements in a vector or evaluations of the polynomial) can be provided as needed to $S_{\sf call}$ or $S_{\sf per}$ with short proofs that they are correct with respect to the stored commitment.

This suggests an optimization for naysayer proofs in a blockchain context: the prover posts only a binding commitment $H(\pi)$, which the contract stores in $S_{\sf per}$, while the actual proof $\pi$ is stored in $S_{\sf DA}$. We assume that potential naysayer{}s can read $\pi$ from $S_{\sf DA}$. In the optimistic case, the full proof $\pi$ is never written to the more-expensive $S_{\sf call}$ or $S_{\sf per}$. In the pessimistic case, when naysaying is necessary, the naysayer must send openings of the erroneous proof elements to the verifier (in $S_{\sf call}$). The verifier checks that these data elements are valid with respect to the on-chain commitment $H(\pi)$ stored in $S_{\sf per}$. Note that in some naysayer proof systems which don't require reading all of $\pi$, even this pessimistic case will offer significant savings over storing all of $\pi$ in $S_{\sf call}$. An important future research direction is to investigate this optimized storage model's implications and implementation details.

%Note that in the optimistic case, naysayer proofs fully shift computation and storage (i.e., access to $x, \pi$) from the verifier to the naysayer. In the pessimistic case, the verifier requires slightly increased storage ($x,\pi, \pi_{\nay}$) but only needs to compute $\vfynay$ instead of $\vfy$. A useful naysayer proof system should compensate for the increased storage cost by considerably reducing verification costs.