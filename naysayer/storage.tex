\section{Storage Considerations}\label{sec:naysayer_storage}

So far, we have assumed that the naysayer verifier can read the instance $x$, the original proof $\pi$ and $\aux$, and the naysayer proof $\pi_\nay$ entirely. A naysayer proof system thus requires increased storage (long-term for $\aux$, and temporary for $\pi_{\nay}$ only in case of a challenge). However, the verifier only needs to compute $\vrfynay$ instead of $\vrfy$. A useful naysayer proof system should therefore compensate for the increased storage by considerably reducing verification costs.

In either case, in blockchain contexts where storage is typically very costly, the approach of storing all data on chain may not be sufficient. Furthermore, as we pointed out previously, the verifier---the only entity which requires data to be stored on-chain in order to access it---does not access all of this data.

Blockchains such as Ethereum differentiate costs between persistent storage (which we can call $S_{\sf per}$) and ``call data'' ($S_{\sf call}$), which is available only for one transaction and is significantly cheaper as a result. Verifiable computation proofs, for example, are usually stored in $S_{\sf call}$ with only the verification result persisted to $S_{\sf per}$.

Some applications now use a third, even cheaper, tier of data storage, namely off-chain \emph{data availability services} ($S_{\sf DA}$), which promise to make data available off-chain but which on-chain contracts have no ability to read. Verifiable storage, an analog of verifiable computation, enables a verifier to store only a short commitment to a large vector~\cite{PKC:CatFio13,C:Merkle87} or polynomial~\cite{AC:KatZavGol10}, with an untrusted storage provider ($S_{\sf DA}$) storing the full values. Individual data items (elements in a vector or evaluations of the polynomial) can be provided as needed to $S_{\sf call}$ or $S_{\sf per}$ with short proofs that they are correct with respect to the stored commitment.  (Ethereum implemented this type of storage, commonly referred to as ``blob data'', using KZG commitments in EIP-4844~\cite{eip4844}.)

This suggests an optimization for naysayer proofs in a blockchain context: the prover posts only a binding commitment $\Commit(\pi')$, which the contract stores in $S_{\sf per}$, while the actual proof $\pi' = (\pi, \aux)$ is stored in $S_{\sf DA}$. We assume that potential naysayers can read $\pi'$ from $S_{\sf DA}$. In the optimistic case, the full proof $\pi'$ is never written to the more-expensive $S_{\sf call}$ or $S_{\sf per}$. In the other case, when naysaying is necessary, the naysayer must send openings of the erroneous elements to the verifier (in $S_{\sf call}$), who checks that these data elements are valid with respect to the on-chain commitment $\Commit(\pi')$ stored in $S_{\sf per}$. Note that most naysayer proof systems don't require reading all of $\pi'$ for verification, so even the pessimistic case will offer significant savings over storing all of $\pi'$ in $S_{\sf call}$. 
% An important future research direction is to investigate this optimized storage model's implications and implementation details.

%Note that in the optimistic case, naysayer proofs fully shift computation and storage (i.e., access to $x, \pi$) from the verifier to the naysayer. In the pessimistic case, the verifier requires slightly increased storage ($x,\pi, \pi_{\nay}$) but only needs to compute $\vfynay$ instead of $\vfy$. A useful naysayer proof system should compensate for the increased storage cost by considerably reducing verification costs.