% \subsection{Anonymous Atomic Locks for coin mixing and cross-chain payments}
\subsection{Cryptocurrency Mixers}

\noemi{How to position this? Our focus will be on \emph{off-chain} mixers, whose focus is on enabling \emph{scalability} and \emph{interoperability} rather than privacy...}
\todo{Talk about how these also solve scalability and interoperability?}

\todo{citations \cite{ESORICS:RufMorKat14,EPRINT:SNBB19,ACSAC:TLKBS18,FC:BNMCKF14}, Bitcoin (CoinJoin, CoinShuffle), Bolt, Blindcoin, Mixcoin}
Cryptocurrency mixers add a measure of $k$-anonymity to cryptocurrency tokens by employing a central party, or \emph{mixer}, to shuffle the tokens among users of the service. Users deposit their coins into the service, and later retrieve them again (using a different address, otherwise anonymity is trivially broken).
Any particular token (retrieved from the mixer) cannot be tied to a particular source (user who deposited money from the mixer): each of the $k$ users is equally likely to be the source of a given token. For security, a mixer must offer \emph{atomicity}, i.e., a user pays $c+\epsilon$ coins if and only if the ``recipient'' (normally the same user, but under a new address) is paid $c$ coins ($\epsilon$ is a parameter which represents the mixer and transaction fees). \todo{exit scams}

Mixers come in two flavors: on- and off-chain mixers. On-chain mixers~\todo{\cite{}} are simply accounts into which users can deposit coins and later retrieve them (or allow another party to retrieve them) by redeeming some token, with atomicty enforced via an on-chain script.\noemi{check this} 

Off-chain mixers normally require more complicated protocols to enforce the atomicity requirement without the scripting functionality offered by the underlying blockchain. One line of work, initiated by TumbleBit~\cite{NDSS:HABSG17}, uses a protocol paradigm which we refer to as a \emph{synchronization puzzle}. A synchronization puzzle is a three-party protocol between a sender (Alice), a mixer (Hub), and a recipient (Bob) \todo{insert figure}. Synchronization puzzle protocols consist of four steps: (1) Hub and Bob execute \emph{puzzle promise} phase with respect to some message $m_{HB}$, which outputs a puzzle $\tau$ containing a hidden signature $s$ on $m_{HB}$. (2) Bob sends $\tau$ to Alice via a private channel, who (3) uses it to execute the \emph{puzzle solver} phase with Hub with respect to another message $m_{AH}$. At the end of this phase, Alice obtains the signature $s$ on $m_{HB}$ and Hub learns $s'$ on $m_{AH}$. To conclude, (4) Alice sends $s$ to Bob. A synchronization puzzle protocol should satisfy the following properties:
\begin{itemize}
    \item \textbf{Blindness}: In the puzzle solver phase, Hub \emph{blindly} helps solve $\tau$, i.e., the phase should not reveal anything about $\tau$ to Hub. (This keeps Alice and Bob unlinkable from the point of view of Hub.)
    \item \textbf{Unlockability}: If the puzzle solver phase completes successfully, $s$ must be a valid secret for $\tau$. (This ensures that the Hub cannot learn $s'$ without revealing $s$.)
    \item \textbf{Unforgeability}: Bob cannot output a valid signature $s$ on $m_{HB}$ before the puzzle solver phase completes. (This ensures Bob cannot learn $s$ without Hub learning $s'$.)
\end{itemize}
To use a synchronization puzzle to realize an atomic payment, the parties set $m_{AH} : (A \xrightarrow{c+\epsilon} H)$ and $m_{HB} : (H \xrightarrow{c} B)$, where $(U_i \xrightarrow{c} U_j)$ denotes a payment of $c$ coins from user $U_i$ to $U_j$. Then $s'$ and $s$ are set to the signatures authorizing $m_{AH}$ and $m_{HB}$, respectively. Thus, at the completion of the protocol Alice will have sent $c$ coins to Bob (and paid a fee of $\epsilon$ to Hub).

Tumblebit realizes a synchronization puzzle via \todo{???}. 
% TumbleBit is an off-chain Bitcoin mixer with strong unlinkability and security properties even against a malicious mixer. Underpinning their protocol is the new notion of a \emph{synchronization puzzle}, 

Before we describe the approach to instantiating synchronization puzzles taken by follow-up work~\cite{SP:TaiMorMaf21}, we introduce the notion of \emph{adaptor signatures}.

\begin{definition}[adaptor signature~\cite{AC:AEEFHM21}]
    An adaptor signature scheme $\Pi_\ADP := (\kgen, \presig, \prevrfy, \adapt, \vrfy, \ext)$ is defined with respect to a digital signature scheme $\Pi_\DS$ and an NP relation $\Rel$:
    \begin{description}
        \item[$\kgen(\secparam) \to (\vk, \sk)$:] The key generation algorithm is the same as in the underlying digital signature scheme, i.e., $\Pi_\DS.\kgen$.
        \item[$\presig(\sk, m, Y) \to \tilde{\sigma}$:] The pre-signing algorithm takes as input a signing key $\sk$, message $m$, and instance $Y$ of the relation $\Rel$ and returns a pre-signature $\tilde{\sigma}$.
        \item[$\prevrfy(\vk, m, Y, \tilde{\sigma}) \to \{0, 1\}$:] The pre-verification algorithm checks that a pre-signature is well-formed.
        \item[$\adapt(\tilde{\sigma}, y) \to \sigma$:] Given a witness $y$ for the instance $Y$, this algorithm adapts the pre-signature $\tilde{\sigma}$ into a valid signature $\sigma$.
        \item[$\vrfy(\vk, m, \sigma) \to \{0, 1\}$:] The verification algorithm is the same as in the underlying digital signature scheme, i.e., $\Pi_\DS.\vrfy$.
        \item[$\ext(\tilde{\sigma}, \sigma, Y) \to y$:] Given a pre-signature $\tilde{sigma}$ and a signature $\sigma$ generated with respect to some instance $Y$, the extract algorithm outputs the corresponding witness $y$ such that $(Y, y) \in \Rel$.
    \end{description}
\end{definition}

An adaptor signature scheme should satisfy the following properties: \emph{pre-signature correctness}, which guarantees that for all instances $Y \in \Lang_Rel$ and honestly generated $\tilde{\sigma}, \sigma$, the pre-signature and signature pass (pre-)verification and the extracted witness $y' \gets \ext(\tilde{\sigma}, \sigma, Y)$ should satisfy $(Y, y') \in \Rel$; \emph{unforgeability}, which is a straightforward extension of the standard existential unforgeability notion (EUF-CMA) for digital signatures; \emph{pre-signature adaptability}, which states that for any $Y \in \Lang_\Rel$ and corresponding pre-signature $\tilde{\sigma}$, pre-verification implies that $\tilde{\sigma}$ can be adapted to a verifying signature $\sigma$; and \emph{witness extractability}, which says that it is difficult for an adversary to adapt an honestly-generated pre-signature $\tilde{\sigma}$ into a signature $\sigma$ which verifies but where $y' \gets \ext(\tilde{\sigma}, \sigma, Y)$ such that $(Y, y') \notin \Lang_\Rel$. We refer the reader to \cite{CCS:GMMMTT22} for formal definitions.

Anonymous Atomic Locks (\AAL)~\cite{SP:TaiMorMaf21} uses a rerandomizable CPA-secure encryption scheme $\Pi_\ENC$ and an \emph{adaptor signature} scheme $\Pi_\ADP$ to realize a synchronization puzzle which is compatible with a wider range of cryptocurrencies. \todo{...}


\subsubsection{Blind Conditional Signatures}
In this section, we summarize the contributions and constructions of~\cite{CCS:GMMMTT22}. In this paper, we analyzed the \AAL protocol~\cite{SP:TaiMorMaf21} and found that, in contrast to its claims, it is not secure. Although \AAL was proven secure in the universal composability (UC)~\cite{FOCS:Canetti01} framework, we show that a gap in their formal model allows two constructions which are completely insecure despite meeting their definitions: one admits a key recovery attack and the other allows a colluding sender and recipient to steal coins from the mixer. To close this gap, we introduce a new primitive called blind conditional signtaures (BCS) which captures the core coin mixing functionality. We give game-based security definitions for BCS and show how to modify \AAL to obtain a new protocol, \AALplus, which meets these definitions. We also give a UC-secure construction of BCS, dubbed \AALUC, which requires much more complex machinery. 

\paragraph{Counterexamples to \AAL.} We show that there exist cryptographic primitives which satisfy the prerequisites of \AAL's main theorem, but allow \textit{(a)} a \emph{key recovery attack}, in which a malicious user is able to learn the long-term secret of the hub or \textit{(b)} a \emph{one-more signature attack}, in which a sender and recipient can collude to obtain $n$ tokens from the hub while only sending $n-1$ tokens. Both attacks run in polynomial time and succeed with overwhelming probability. These instantiations of \AAL are specifically crafted allow an attack and do not imply that all instantiations of \AAL are broken; however, we cannot prove the security of \AAL either. This gap is discussed further below.

Below we give informal descriptions of both attacks below. We refer the reader to \cite{CCS:GMMMTT22} for detailed descriptions and analysis. Both attacks rely on the fact that the \AAL protocol offers a malicious Alice what amounts to a decryption oracle. This oracle, which we refer to as $\oracle^\text{\AAL}$, takes as input a verification key $\vk$, message $m$, group element $h$, ciphertext $c$, and pre-signature $\tilde{\sigma}$. It computes \todo{...}

\textit{Key recovery attack.} 

\todo{write intuitive explanation of the attacks, refer to full paper for details}

\paragraph{Definitions.} \todo{Write game-based defs, refer reader to A2L and our paper for UC ideal functionality}

\paragraph{Constructions.} \todo{Write both constructions?}
